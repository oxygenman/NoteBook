#                                      C语言基础

## 1指针

### 1.1指针的本质

指针的本质是一个有类型的地址，在32位机中指针大小4个字节，在64位中占8个字节。指针的类型代表了指针的寻址范围(即其所存放地址的寻址能力)。*代表了这是一个指针变量，占四个字节。指针变量的定义：type * Variable;

不同类型指针，可以赋值，编译器会complian,对于指针类型的complia最好解决一下，用强转方式，明确来意

指针运算的加1加的是指针类型的大小

数组名是一个指针常量，不能赋值。

*p++实际上算的是p++而不是内容的++

## 2函数

### 2.1函数的传值和传址

传值：特点:变量从调用空间传到被调用空间后，两者再也没有联系。

传址：操作调用空间

{}用来限定作用域，并不影响执行流程

小作用域出现了与大作用域重名的变量，屏蔽。

全局变量，大括号以外的变量叫做全局变量。

作用域是从定义的地方开始，到他所在的大括号截止。

未初始化状态，局部变量的值是随机的，全局变量系统默认初始化为0.

全局变量作用域从定义开始到本文件结束

局部变量的生命周期，开始于所在函数调用，结束于所在函数调用完毕。

//main()有操作系统发起调用。main函数的局部变量生命周期等同于main（）进程。

全局变量的生命周期，开始于Main函数调用，结束于main()结束。具有整个进程的生命周期。

不要随便定义全局变量，除非有专人管理。

### 2.2关键字

etern关键字，加上extern关键字修饰全局变量，可以避免全局变量重命名的错误。

（王桂林66讲）。extern只能修饰声明变量，不能用在定义变量。虽然可以省略，但是为了避免重定义 ，最好还是加上。extern说明这个全局变量是在别的文件里定义的，extern 是用来引用另一个文件中的变量或函数。

### 2.3C语言中的字符串

c语言中没有字符串类型。

常见的常量，出现在代码段。

内存中分代码段和数据段。

数据段又分为初始化数据段 和非初始化数据段

字符串常量存储在数据段的的只读数据段。

字符串本身是以常量存在，但是，有这样的需要，去改变字符串的内容，此时就需要把字符串常量，放到字符数组中去。

为了使字符串可修改，需要将字符串存在字符数组中。

字符数组能不能完全表达字符串的等价是：

必须把字符串中的\0放进来。

```c
char buf[100]={0}//输入的时候不能越界
scanf("%s",buf)
gets(buf)
puts(buf)
```

## 3.内存空间

### 3.1 栈存储的特点

只存储auto类型。即用即销。容易溢出。

### 3.2堆内存的特点

堆内存可以存放任意类型的数据，需要自己申请和释放。

堆大小，想象中的无穷大，对于栈来说。但实际使用中，受限于实际内存的大小和内存是否连续。

分配堆内存：malloc() free()配对使用。calloc()申请空间并整理

在内存中其实是按照堆框架或者栈框架

### 3.3动态数组

### 3.4内存分配易错

服务器模型，两次malloc,可能造成内存泄漏

不能违背谁申请谁释放的原则

## 4结构体（struct）

### 4.1每一种构造类型都要解决的问题就是成员访问的问题。

```c
struct{
  char name[]
  int age
  char sex
} stu;//定义类型的同时定义变量，无名结构体不引入新的类型。

struct student{
  char name[]
    int age
    char sex
}//有名结构体，一次定义，多处使用，会带来新的命名。

typedef struct Student
{
  char name[];
  int age
    char sex;
} STU;/使用typedef
```

typedef使用步骤

1，先用要起别名的类型，定义一个变量

2，在类型的前面加上typedef

3,将变量名换成你想要的变量名

凡是基本数据类型，既可以定义时初始化，也可以先定义再赋值

凡是构造类型，要么在定义时初始化；不可以先定义再初始化。

STU *ps = &stu//通过指针修改，完成初始化访问。

ps->name//指针 指向成员运算符。

&ps->age//指针

同类结构体可以赋值。

## 5.链表

### 5.1创建链表

所谓头插法，就是每次都插在头节点的后面。

让新来的节点，先有所指向。

新节点有所指向，就不会打断原有的指向关系。

```C
cur.next=head.next;
head.next=cur;
```

尾插法

尾插法，每次把节点插到尾节点的后面。

关键是每次要记录尾节点的位置。

```
pt=head

pt.next=cur;
cur.next=NULL;
pt=cur
```

## 6文件

fopne()

fclose()有刷缓冲的功能

int feof(FILE*p)

feof的置位总滞后于读。

r 只能读现有文件，若不存在，则报错

w 若不存在，则创建，若已存在，则清空

fputs()

fgets()         

//fread(起始地址，最小单元，读取个数，文件句柄)

