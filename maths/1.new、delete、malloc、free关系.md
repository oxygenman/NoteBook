# 1.new、delete、malloc、free关系

delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

# 2.delete与 delete []区别

delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套

3.解释下protobuf,protobuf的原理？相比json\xml的有点



4.c++面向对象有哪几个特点？ c++中多态有几种？多态，虚函数，纯虚函数

封装继承多态

C++ 中的多态性具体体现在编译和运行两个阶段。编译时多态是静态多态，在编译时就可以确定使用的接口。运行时多态是动态多态，具体引用的接口在运行时才能确定。

![在这里插入图片描述](https://xy-cloud-images.oss-cn-shanghai.aliyuncs.com/img/20180919171158694)



5.什么是数据库事务？事务的四大特性？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响
6.

1.线程的基本概念？线程的四种状态

线程，有时称为轻量级进程，是CPU使用的基本单元；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。

线程有四种状态：新生状态、可运行状态、被阻塞状态、死亡状态。状态之间的转换如下图所示：

2.进程和线程有什么区别？

这个一个最常见，却最不好回答的问题，csdn上面一位博主给出的[解答](http://blog.csdn.net/forrest2009/article/details/6413756)和另一位cnblog博主的[解答](http://www.cnblogs.com/engine1984/archive/2007/08/22/865562.html)稍微清晰些一些，总结起来，就是一下的几个区别：

　　　　a.进程是资源分配的基本单位，线程是cpu调度，或者说是程序执行的最小单位。在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。

　　　　b.进程有独立的地址空间，比如在linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和堆栈（注意不是堆）的，比如在windows中用[_beginthreadex](http://blog.csdn.net/morewindows/article/details/7421759)创建一个新进程就会在调用CreateThread的同时申请一个专属于线程的数据块（_tiddata)。

　　　　c.线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过[进程通信](http://baike.baidu.com/view/549640.htm)的方式进行。

　　　　d.由b，可以轻易地得到结论：多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在[保护模式](http://blog.csdn.net/wukaiyu/article/details/1766804)下，一个进程死掉对另一个进程没有直接影响。

　　　　e.线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。

4.c++怎么创建线程？

7.定义一个数组的指针？



8.c++内存的分配方式有几种 ？

9？什么是缓存穿透 缓存穿透的解决方案？

10？ 使用过thrift吗？说一下thrift se

11.c++静态数据成员的初始化方式？





